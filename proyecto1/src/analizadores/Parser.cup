package analizadores;

import java.util.*;
import servicios.AutomataRegistry;
import modelo.*;

/* Símbolos terminales */
terminal LPAR, RPAR, LBRACE, RBRACE, COMMA, COLON, SEMI, OR, ARROW, EQ, LT, GT, LT_SLASH;
terminal TRANSICIONES, NOMBRE, KAFD, KAP, N, T, I, A, P, VER, DESC, LAMBDA, HASH;
terminal String ID, STRING, SYM;
terminal EOF, ERROR;

/* Símbolos no terminales */
non terminal programa, lista_sentencias, sentencia;
non terminal definicion_afd, definicion_ap;
non terminal String identificador, simbolo;
non terminal List lista_ids, lista_simbolos;
non terminal List secciones_afd, transiciones_afd, transiciones_ap;
non terminal Set conjunto_estados, conjunto_alfabeto, conjunto_inicial, conjunto_aceptacion, conjunto_pila;
non terminal List todas_trans_afd, una_trans_afd;
non terminal List todas_trans_ap, una_trans_ap;

/* Precedencias */
precedence left OR;

/* Símbolo inicial */
start with programa;

/* Reglas de producción */
programa ::= lista_sentencias
          |  /* vacío */
          ;

lista_sentencias ::= lista_sentencias sentencia
                  |  sentencia
                  ;

sentencia ::= definicion_afd
           |  definicion_ap  
           |  VER LPAR RPAR SEMI         {: AutomataRegistry.listar(); :}
           |  DESC LPAR identificador RPAR SEMI  {: AutomataRegistry.desc($3); :}
           |  identificador LPAR STRING RPAR SEMI {: AutomataRegistry.validar($1, quitarComillas($3)); :}
           ;

identificador ::= ID {: RESULT = $1; :};

simbolo ::= ID     {: RESULT = $1; :}
         |  SYM    {: RESULT = $1; :}
         |  LAMBDA {: RESULT = "$"; :}
         |  HASH   {: RESULT = "#"; :}
         ;

/* === Definición de AFD === */
definicion_afd ::= LT KAFD NOMBRE EQ STRING GT
                     secciones_afd
                   LT_SLASH KAFD GT
                   {:
                     String nombre = quitarComillas($5);
                     Map<String, Set<String>> conjuntos = (Map<String, Set<String>>)$7.get(0);
                     List<AFD.Tr> trans = (List<AFD.Tr>)$7.get(1);
                     AFD afd = new AFD(nombre, conjuntos.get("N"), conjuntos.get("T"), 
                                      obtenerUno(conjuntos,"I"), conjuntos.get("A"), trans);
                     AutomataRegistry.add(afd);
                   :}
                ;

secciones_afd ::= conjunto_estados conjunto_alfabeto conjunto_inicial conjunto_aceptacion transiciones_afd
                  {:
                    Map<String, Set<String>> conjuntos = new HashMap<>();
                    conjuntos.put("N", (Set<String>)$1);
                    conjuntos.put("T", (Set<String>)$2);  
                    conjuntos.put("I", (Set<String>)$3);
                    conjuntos.put("A", (Set<String>)$4);
                    List<Object> resultado = new ArrayList<>();
                    resultado.add(conjuntos);
                    resultado.add($5);
                    RESULT = resultado;
                  :}
                ;

conjunto_estados     ::= N EQ LBRACE lista_ids RBRACE SEMI      {: RESULT = new HashSet<>($4); :};
conjunto_alfabeto    ::= T EQ LBRACE lista_simbolos RBRACE SEMI {: RESULT = new HashSet<>($4); :};
conjunto_inicial     ::= I EQ LBRACE lista_ids RBRACE SEMI      {: RESULT = new HashSet<>($4); :};
conjunto_aceptacion  ::= A EQ LBRACE lista_ids RBRACE SEMI      {: RESULT = new HashSet<>($4); :};

transiciones_afd ::= TRANSICIONES todas_trans_afd SEMI {: RESULT = $2; :};

todas_trans_afd ::= una_trans_afd                           {: RESULT = $1; :}
                 |  todas_trans_afd OR una_trans_afd        {: $1.addAll($3); RESULT = $1; :}
                 ;

una_trans_afd ::= identificador ARROW simbolo COMMA identificador
                  {:
                    List<AFD.Tr> lista = new ArrayList<>();
                    lista.add(new AFD.Tr($1, $3, $5));
                    RESULT = lista;
                  :};

/* === Definición de AP === */
definicion_ap ::= LT KAP NOMBRE EQ STRING GT
                    conjunto_estados conjunto_alfabeto conjunto_pila conjunto_inicial conjunto_aceptacion transiciones_ap
                  LT_SLASH KAP GT
                  {:
                    String nombre = quitarComillas($5);
                    AP ap = new AP(nombre, (Set<String>)$7, (Set<String>)$8, (Set<String>)$9,
                                  obtenerUno($10), $11, (List<AP.Tr>)$12);
                    AutomataRegistry.add(ap);
                  :}
                ;

conjunto_pila ::= P EQ LBRACE lista_simbolos RBRACE SEMI {: RESULT = new HashSet<>($4); :};

transiciones_ap ::= TRANSICIONES todas_trans_ap SEMI {: RESULT = $2; :};

todas_trans_ap ::= una_trans_ap                         {: RESULT = $1; :}
                |  todas_trans_ap OR una_trans_ap       {: $1.addAll($3); RESULT = $1; :}
                ;

una_trans_ap ::= identificador LPAR simbolo RPAR ARROW LPAR simbolo RPAR COMMA identificador COLON LPAR simbolo RPAR
                 {:
                   List<AP.Tr> lista = new ArrayList<>();
                   lista.add(new AP.Tr($1, $3, $7, $10, $13));
                   RESULT = lista;
                 :};

/* === Listas === */
lista_ids ::= identificador                     {: List<String> l = new ArrayList<>(); l.add($1); RESULT = l; :}
           |  lista_ids COMMA identificador     {: $1.add($3); RESULT = $1; :}
           ;

lista_simbolos ::= simbolo                      {: List<String> l = new ArrayList<>(); l.add($1); RESULT = l; :}
                |  lista_simbolos COMMA simbolo {: $1.add($3); RESULT = $1; :}
                ;

/* === Código auxiliar === */
parser code {:
  private static String quitarComillas(String s) {
    if (s != null && s.length() >= 2 && s.startsWith("\"") && s.endsWith("\"")) {
      return s.substring(1, s.length() - 1);
    }
    return s;
  }
  
  private static String obtenerUno(Map<String, Set<String>> mapa, String clave) {
    Set<String> conjunto = mapa.get(clave);
    if (conjunto == null || conjunto.size() != 1) {
      throw new RuntimeException("El conjunto " + clave + " debe tener exactamente 1 elemento");
    }
    return conjunto.iterator().next();
  }
  
  private static String obtenerUno(Set<String> conjunto) {
    if (conjunto == null || conjunto.size() != 1) {
      throw new RuntimeException("El conjunto debe tener exactamente 1 elemento");
    }
    return conjunto.iterator().next();
  }
:};